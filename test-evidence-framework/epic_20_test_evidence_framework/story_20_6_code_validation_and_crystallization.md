# Story 20.6 ‚Äì Code Validation & Test Crystallization

**As the test-evidence crystallizer**,  
I want to validate generated tests for correctness and safety, then commit them into the appropriate service directories  
So that only well-formed, idiomatic tests are merged into the codebase.

## ‚úÖ Acceptance Criteria
- For Java tests generated by Story 20.3:
  - AST parsing or compilation checks confirm the tests compile cleanly.
  - Import rules are validated (e.g., no banned APIs or test-only imports in production code).
  - Annotation usage is validated (e.g., `@StoryRef`, `@AcceptanceCriterion`, `@ServiceUnderTest` are present and correct).
  - Formatting/checkstyle rules are applied and any violations are reported.
- For JS/TS tests generated by Story 20.4:
  - TypeScript compiler checks confirm no type errors.
  - ESLint rules are applied and violations are reported.
  - Story metadata comments (`@StoryRef`, `@ServicesInvolved`) are validated for correct format and content.
- The crystallizer can run in:
  - **Validation-only mode**: reports errors without writing files.
  - **Write mode**: writes validated tests to their target paths under `/backend`, `/gateway`, `/risk-engine`, `/frontend`.
- For each story, the crystallizer:
  - Determines the correct target directory and package/module based on service and test type.
  - Writes or updates test files in those locations.
  - Opens a pull request (or prepares a branch) with:
    - A clear commit message referencing the story ID and title.
    - A PR description listing:
      - Services covered.
      - Number of tests added per service.
      - Links back to the story markdown.
- The crystallizer does not overwrite manually edited tests unless explicitly configured to do so, and logs any conflicts for manual resolution.

## üß™ Test Scenarios
1. **Validate Java tests successfully**  
   Given generated JUnit 5 tests for Story 3.2 in `/backend`  
   When the crystallizer runs in validation mode  
   Then it confirms the tests compile, pass formatting checks, and contain correct annotations.

2. **Detect Java compilation error**  
   Given a generated test with a syntax error  
   When the crystallizer runs  
   Then it reports the error and does not write the file.

3. **Validate React tests successfully**  
   Given generated Jest/RTL tests for Story 3.2 in `/frontend`  
   When the crystallizer runs in validation mode  
   Then it confirms TypeScript types resolve, ESLint passes, and story metadata comments are correct.

4. **Write validated tests to target paths**  
   Given successfully validated tests for multiple services  
   When the crystallizer runs in write mode  
   Then it places tests under `/backend/src/test/java/...`, `/frontend/src/__tests__/...`, etc., with correct structure.

5. **Create PR for story tests**  
   Given validated and written tests for Story 3.2  
   When the crystallizer completes  
   Then it opens a PR on branch `feature/tests/story-3-2` with a summary of added tests per service.

## üõ† Implementation Guidance
- Implement validation as separate modules per language (Java validator, TS/JS validator).
- Use existing tooling where possible (javac, tsc, eslint CLI) rather than reinventing parsers.
- Keep crystallization logic separate from generation logic so validators can be run independently.
- Store configuration (target paths, branch naming patterns, PR templates) in a central config file.

## üì¶ Deliverables
- Java test validator implementation.
- JS/TS test validator implementation.
- Crystallizer orchestrator that runs validators and writes files.
- PR creation logic (Git branch + commit + PR template).
- Unit tests for validation and file-writing logic.
- Short usage guide in the epic README showing how to crystallize tests for a story.

## ‚è≠ Dependencies / Links
- Depends on Stories 20.3 and 20.4 for generated test content.
- Enables Story 20.8 (ReportPortal integration) and Story 20.10 (CI/CD wiring) once tests are merged and running.
