#!/bin/bash
#
# Git Pre-Commit Hook - CDS Platform Quality Gate
#
# This hook runs before each commit to ensure code meets security standards.
# To install: Copy this file to .git/hooks/pre-commit and make it executable
#   cp git-hooks/pre-commit.sample .git/hooks/pre-commit
#   chmod +x .git/hooks/pre-commit
#
# To bypass (emergencies only): git commit --no-verify
#

echo ""
echo "ğŸ”’ Running CDS Platform Quality Gate..."
echo ""

# Get list of changed Java files
CHANGED_FILES=$(git diff --cached --name-only --diff-filter=ACM | grep '\.java$')

if [ -z "$CHANGED_FILES" ]; then
  echo "â„¹ï¸  No Java files changed, skipping quality checks"
  exit 0
fi

echo "ğŸ“ Changed Java files:"
echo "$CHANGED_FILES" | sed 's/^/   /'
echo ""

# Quick pre-commit checks (faster than full SpotBugs)
echo "ğŸ” Running quick security checks..."
echo ""

VIOLATIONS=0

# Check 1: CRLF Injection Pattern
echo -n "âœ“ Checking for CRLF injection patterns... "
if echo "$CHANGED_FILES" | xargs grep -n 'logger\.\(info\|debug\|warn\|error\).*\+.*' 2>/dev/null | grep -v 'sanitizeForLog'; then
  echo "âŒ FAIL"
  echo ""
  echo "âš ï¸  Found potential CRLF injection:"
  echo "$CHANGED_FILES" | xargs grep -n 'logger\.\(info\|debug\|warn\|error\).*\+.*' | grep -v 'sanitizeForLog'
  echo ""
  echo "ğŸ’¡ Fix: Use sanitizeForLog() or ensure input is safe"
  VIOLATIONS=$((VIOLATIONS + 1))
else
  echo "âœ…"
fi

# Check 2: Predictable Random (excluding Demo classes)
echo -n "âœ“ Checking for predictable random... "
if echo "$CHANGED_FILES" | grep -v 'Demo.*Service' | xargs grep -n 'new Random()' 2>/dev/null; then
  echo "âŒ FAIL"
  echo ""
  echo "âš ï¸  Found java.util.Random in production code:"
  echo "$CHANGED_FILES" | grep -v 'Demo.*Service' | xargs grep -n 'new Random()'
  echo ""
  echo "ğŸ’¡ Fix: Use java.security.SecureRandom instead"
  VIOLATIONS=$((VIOLATIONS + 1))
else
  echo "âœ…"
fi

# Check 3: Unicode handling
echo -n "âœ“ Checking for unicode handling... "
if echo "$CHANGED_FILES" | xargs grep -n '\.toUpperCase()\|\.toLowerCase()' 2>/dev/null | grep -v 'Locale\.ROOT\|Locale\.ENGLISH'; then
  echo "âŒ FAIL"
  echo ""
  echo "âš ï¸  Found case conversion without Locale:"
  echo "$CHANGED_FILES" | xargs grep -n '\.toUpperCase()\|\.toLowerCase()' | grep -v 'Locale\.ROOT\|Locale\.ENGLISH'
  echo ""
  echo "ğŸ’¡ Fix: Use .toUpperCase(Locale.ROOT) or .toLowerCase(Locale.ROOT)"
  VIOLATIONS=$((VIOLATIONS + 1))
else
  echo "âœ…"
fi

# Check 4: Information exposure
echo -n "âœ“ Checking for information exposure... "
if echo "$CHANGED_FILES" | xargs grep -n 'printStackTrace()\|\.getMessage()' 2>/dev/null | grep -v 'logger\|log\.'; then
  echo "âš ï¸  WARNING"
  echo ""
  echo "âš ï¸  Found potential information exposure:"
  echo "$CHANGED_FILES" | xargs grep -n 'printStackTrace()\|\.getMessage()' | grep -v 'logger\|log\.'
  echo ""
  echo "ğŸ’¡ Review: Ensure stack traces are not exposed to clients"
else
  echo "âœ…"
fi

# Check 5: Hardcoded secrets
echo -n "âœ“ Checking for hardcoded secrets... "
if echo "$CHANGED_FILES" | xargs grep -n -i 'password.*=.*"\|secret.*=.*"\|apikey.*=.*"' 2>/dev/null | grep -v 'sanitizeForLog\|//'; then
  echo "âŒ FAIL"
  echo ""
  echo "ğŸš¨ CRITICAL: Found potential hardcoded secrets:"
  echo "$CHANGED_FILES" | xargs grep -n -i 'password.*=.*"\|secret.*=.*"\|apikey.*=.*"' | grep -v 'sanitizeForLog\|//'
  echo ""
  echo "ğŸ’¡ Fix: Use environment variables or configuration files"
  VIOLATIONS=$((VIOLATIONS + 1))
else
  echo "âœ…"
fi

# Check 6: SQL injection patterns
echo -n "âœ“ Checking for SQL injection patterns... "
if echo "$CHANGED_FILES" | xargs grep -n 'createNativeQuery.*+\|createQuery.*+' 2>/dev/null; then
  echo "âŒ FAIL"
  echo ""
  echo "âš ï¸  Found potential SQL injection:"
  echo "$CHANGED_FILES" | xargs grep -n 'createNativeQuery.*+\|createQuery.*+'
  echo ""
  echo "ğŸ’¡ Fix: Use parameterized queries instead of string concatenation"
  VIOLATIONS=$((VIOLATIONS + 1))
else
  echo "âœ…"
fi

# Check 7: Missing input validation
echo -n "âœ“ Checking for input validation... "
if echo "$CHANGED_FILES" | xargs grep -l '@PostMapping\|@PutMapping' 2>/dev/null | xargs grep -L '@Valid'; then
  echo "âš ï¸  WARNING"
  echo ""
  echo "âš ï¸  Controllers with POST/PUT but possibly missing @Valid:"
  echo "$CHANGED_FILES" | xargs grep -l '@PostMapping\|@PutMapping' | xargs grep -L '@Valid'
  echo ""
  echo "ğŸ’¡ Review: Ensure @Valid is used on @RequestBody parameters"
else
  echo "âœ…"
fi

echo ""
echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"

# Note: We don't check for missing @PreAuthorize as authorization strategy varies by endpoint type:
# - Public endpoints (health checks) don't need @PreAuthorize
# - Internal service APIs use service token validation
# - User-facing APIs should have @PreAuthorize
# Security review should verify appropriate authorization per endpoint

if [ "$VIOLATIONS" -gt 0 ]; then
  echo "âŒ PRE-COMMIT CHECK FAILED"
  echo ""
  echo "   Critical Violations: $VIOLATIONS"
  echo ""
  echo "ğŸ“‹ Action Required:"
  echo "   1. Fix the violations listed above"
  echo "   2. Review AGENTS.md for security standards"
  echo "   3. Review .github/CODE_QUALITY_RULES.md for detailed rules"
  echo ""
  echo "ğŸ’¡ To run full quality gate: ./quality-gate-check.sh"
  echo ""
  echo "âš ï¸  To bypass (emergencies only): git commit --no-verify"
  echo ""
  exit 1
else
  echo "âœ… PRE-COMMIT CHECKS PASSED"
  echo ""
  echo "ğŸ’¡ Consider running full quality gate before pushing:"
  echo "   ./quality-gate-check.sh"
  echo ""
  exit 0
fi
