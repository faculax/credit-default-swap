/**
 * Story 3.1 - CDS Trade Capture UI & Reference Data
 * 
 * Complete test implementation covering all acceptance criteria:
 * - AC1: All fields displayed from Epic 3 inventory
 * - AC2: Required fields marked and validated
 * - AC3: Dropdowns populated from reference data
 * - AC4: Default pre-populations applied
 * - AC5: Restructuring Clause optional
 * - AC6: Basic inline validation (presence + numeric >= 0)
 * - AC7: Responsive layout (desktop vs mobile)
 * 
 * Generated by: Test Evidence Framework
 * Idempotent: Safe to regenerate
 */

import { render, screen, waitFor } from '@testing-library/react';
import userEvent from '@testing-library/user-event';
import { allure } from 'allure-jest';
import { CDSTradeForm } from '@/components/CDSTradeForm';

describe('Story 3.1 - CDS Trade Capture UI & Reference Data', () => {
  beforeEach(() => {
    allure.epic('Epic 03 - CDS Trade Capture');
    allure.feature('Trade Form UI');
    allure.story('3.1 - CDS Trade Capture UI & Reference Data');
    allure.severity('critical');
  });

  /**
   * AC1: Form displays all fields listed in Epic 3 field inventory
   */
  it('should display all required CDS trade fields from Epic 3 inventory', () => {
    // GIVEN
    allure.description('Verify that all mandatory CDS trade fields are rendered in the form');

    // WHEN
    render(<CDSTradeForm />);

    // THEN - Temporal fields
    expect(screen.getByLabelText(/trade date/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/effective date/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/maturity date/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/accrual start date/i)).toBeInTheDocument();

    // THEN - Economic fields
    expect(screen.getByLabelText(/notional amount/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/spread/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/currency/i)).toBeInTheDocument();

    // THEN - Convention fields
    expect(screen.getByLabelText(/premium frequency/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/day count convention/i)).toBeInTheDocument();

    // THEN - Trade metadata
    expect(screen.getByLabelText(/buy\/sell protection/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/payment calendar/i)).toBeInTheDocument();
    expect(screen.getByLabelText(/restructuring clause/i)).toBeInTheDocument();
  });

  /**
   * AC2: Required fields visually marked (asterisk) and cannot submit when empty
   */
  it('should mark required fields with asterisk and prevent submission when empty', async () => {
    // GIVEN
    allure.description('Verify required field indicators and validation on submit');
    const user = userEvent.setup();
    render(<CDSTradeForm />);

    // THEN - Visual indicators present
    expect(screen.getByText(/notional amount \*/i)).toBeInTheDocument();
    expect(screen.getByText(/spread \*/i)).toBeInTheDocument();
    expect(screen.getByText(/trade date \*/i)).toBeInTheDocument();
    expect(screen.getByText(/effective date \*/i)).toBeInTheDocument();
    expect(screen.getByText(/maturity date \*/i)).toBeInTheDocument();

    // WHEN - Attempt to submit without filling required fields
    const submitButton = screen.getByRole('button', { name: /submit|save|create/i });
    await user.click(submitButton);

    // THEN - Validation errors appear
    await waitFor(() => {
      expect(screen.getByText(/notional amount is required/i)).toBeInTheDocument();
    });
  });

  /**
   * AC3: Dropdowns populated from reference data lists
   */
  it('should populate dropdown fields with reference data', async () => {
    // GIVEN
    allure.description('Verify all dropdown options are available from reference data');
    const user = userEvent.setup();
    render(<CDSTradeForm />);

    // WHEN - Open currency dropdown
    const currencyDropdown = screen.getByLabelText(/currency/i);
    await user.click(currencyDropdown);

    // THEN - Currency options available
    await waitFor(() => {
      expect(screen.getByRole('option', { name: 'USD' })).toBeInTheDocument();
      expect(screen.getByRole('option', { name: 'EUR' })).toBeInTheDocument();
      expect(screen.getByRole('option', { name: 'GBP' })).toBeInTheDocument();
      expect(screen.getByRole('option', { name: 'JPY' })).toBeInTheDocument();
    });

    // WHEN - Open premium frequency dropdown
    const frequencyDropdown = screen.getByLabelText(/premium frequency/i);
    await user.click(frequencyDropdown);

    // THEN - Frequency options available
    await waitFor(() => {
      expect(screen.getByRole('option', { name: /quarterly/i })).toBeInTheDocument();
      expect(screen.getByRole('option', { name: /annually/i })).toBeInTheDocument();
      expect(screen.getByRole('option', { name: /semi.?annually/i })).toBeInTheDocument();
    });

    // WHEN - Open day count convention dropdown
    const dayCountDropdown = screen.getByLabelText(/day count convention/i);
    await user.click(dayCountDropdown);

    // THEN - Day count options available
    await waitFor(() => {
      expect(screen.getByRole('option', { name: /act.?360/i })).toBeInTheDocument();
      expect(screen.getByRole('option', { name: /act.?365/i })).toBeInTheDocument();
      expect(screen.getByRole('option', { name: /30.?360/i })).toBeInTheDocument();
    });
  });

  /**
   * AC4: Default pre-populations applied correctly
   */
  it('should pre-populate fields with correct default values', () => {
    // GIVEN
    allure.description('Verify all default values are set on form load');

    // WHEN
    render(<CDSTradeForm />);

    // THEN - Trade date defaults to today
    const tradeDateInput = screen.getByLabelText(/trade date/i) as HTMLInputElement;
    const today = new Date().toISOString().split('T')[0];
    expect(tradeDateInput.value).toBe(today);

    // THEN - Currency defaults to USD
    const currencySelect = screen.getByLabelText(/currency/i) as HTMLSelectElement;
    expect(currencySelect.value).toBe('USD');

    // THEN - Premium frequency defaults to QUARTERLY
    const frequencySelect = screen.getByLabelText(/premium frequency/i) as HTMLSelectElement;
    expect(frequencySelect.value).toBe('QUARTERLY');

    // THEN - Day count convention defaults to ACT_360
    const dayCountSelect = screen.getByLabelText(/day count convention/i) as HTMLSelectElement;
    expect(dayCountSelect.value).toBe('ACT_360');

    // THEN - Buy/Sell defaults to BUY
    const buySellSelect = screen.getByLabelText(/buy\/sell protection/i) as HTMLSelectElement;
    expect(buySellSelect.value).toBe('BUY');

    // THEN - Payment calendar defaults to NYC
    const calendarSelect = screen.getByLabelText(/payment calendar/i) as HTMLSelectElement;
    expect(calendarSelect.value).toBe('NYC');
  });

  /**
   * AC5: Restructuring Clause optional - blank allowed
   */
  it('should allow empty restructuring clause field and submit successfully', async () => {
    // GIVEN
    allure.description('Verify optional field does not block submission');
    const user = userEvent.setup();
    const mockSubmit = jest.fn();
    render(<CDSTradeForm onSubmit={mockSubmit} />);

    // WHEN - Fill all required fields except restructuring clause
    await user.type(screen.getByLabelText(/notional amount/i), '1000000');
    await user.type(screen.getByLabelText(/spread/i), '150');
    await user.type(screen.getByLabelText(/effective date/i), '2025-01-15');
    await user.type(screen.getByLabelText(/maturity date/i), '2030-01-15');

    // Leave restructuring clause empty
    const restructuringInput = screen.getByLabelText(/restructuring clause/i) as HTMLInputElement;
    expect(restructuringInput.value).toBe('');

    // WHEN - Submit form
    const submitButton = screen.getByRole('button', { name: /submit|save|create/i });
    await user.click(submitButton);

    // THEN - No validation error for restructuring clause
    await waitFor(() => {
      expect(screen.queryByText(/restructuring clause.*required/i)).not.toBeInTheDocument();
    });
  });

  /**
   * AC6 - Validation Rule 1: Notional Amount > 0
   */
  it('should validate that notional amount is greater than zero', async () => {
    // GIVEN
    allure.description('Test inline validation for notional amount > 0');
    const user = userEvent.setup();
    render(<CDSTradeForm />);

    const notionalInput = screen.getByLabelText(/notional amount/i);

    // WHEN - Enter zero value
    await user.clear(notionalInput);
    await user.type(notionalInput, '0');
    await user.tab(); // Trigger blur validation

    // THEN - Error appears
    await waitFor(() => {
      expect(screen.getByText(/notional amount must be greater than 0/i)).toBeInTheDocument();
    });

    // WHEN - Enter negative value
    await user.clear(notionalInput);
    await user.type(notionalInput, '-1000');
    await user.tab();

    // THEN - Error persists
    await waitFor(() => {
      expect(screen.getByText(/notional amount must be greater than 0/i)).toBeInTheDocument();
    });

    // WHEN - Enter valid positive value
    await user.clear(notionalInput);
    await user.type(notionalInput, '1000000');
    await user.tab();

    // THEN - Error disappears
    await waitFor(() => {
      expect(screen.queryByText(/notional amount must be greater than 0/i)).not.toBeInTheDocument();
    });
  });

  /**
   * AC6 - Validation Rule 2: Spread >= 0
   */
  it('should validate that spread is non-negative', async () => {
    // GIVEN
    allure.description('Test inline validation for spread >= 0');
    const user = userEvent.setup();
    render(<CDSTradeForm />);

    const spreadInput = screen.getByLabelText(/spread/i);

    // WHEN - Enter negative value
    await user.clear(spreadInput);
    await user.type(spreadInput, '-50');
    await user.tab();

    // THEN - Error appears
    await waitFor(() => {
      expect(screen.getByText(/spread must be 0 or greater/i)).toBeInTheDocument();
    });

    // WHEN - Enter zero (valid)
    await user.clear(spreadInput);
    await user.type(spreadInput, '0');
    await user.tab();

    // THEN - No error
    await waitFor(() => {
      expect(screen.queryByText(/spread must be 0 or greater/i)).not.toBeInTheDocument();
    });

    // WHEN - Enter positive value
    await user.clear(spreadInput);
    await user.type(spreadInput, '150');
    await user.tab();

    // THEN - No error
    await waitFor(() => {
      expect(screen.queryByText(/spread must be 0 or greater/i)).not.toBeInTheDocument();
    });
  });

  /**
   * AC6 - Validation Rule 3: Effective Date >= Trade Date
   */
  it('should validate that effective date is not before trade date', async () => {
    // GIVEN
    allure.description('Test date validation: effectiveDate >= tradeDate');
    const user = userEvent.setup();
    render(<CDSTradeForm />);

    const tradeDateInput = screen.getByLabelText(/trade date/i);
    const effectiveDateInput = screen.getByLabelText(/effective date/i);

    // WHEN - Set trade date
    await user.clear(tradeDateInput);
    await user.type(tradeDateInput, '2025-01-15');

    // WHEN - Set effective date before trade date
    await user.clear(effectiveDateInput);
    await user.type(effectiveDateInput, '2025-01-10');
    await user.tab();

    // THEN - Error appears
    await waitFor(() => {
      expect(screen.getByText(/effective date must be on or after trade date/i)).toBeInTheDocument();
    });

    // WHEN - Set effective date equal to trade date
    await user.clear(effectiveDateInput);
    await user.type(effectiveDateInput, '2025-01-15');
    await user.tab();

    // THEN - No error
    await waitFor(() => {
      expect(screen.queryByText(/effective date must be on or after trade date/i)).not.toBeInTheDocument();
    });

    // WHEN - Set effective date after trade date
    await user.clear(effectiveDateInput);
    await user.type(effectiveDateInput, '2025-01-20');
    await user.tab();

    // THEN - No error
    await waitFor(() => {
      expect(screen.queryByText(/effective date must be on or after trade date/i)).not.toBeInTheDocument();
    });
  });

  /**
   * AC6 - Validation Rule 4: Maturity Date > Effective Date
   */
  it('should validate that maturity date is after effective date', async () => {
    // GIVEN
    allure.description('Test date validation: maturityDate > effectiveDate');
    const user = userEvent.setup();
    render(<CDSTradeForm />);

    const effectiveDateInput = screen.getByLabelText(/effective date/i);
    const maturityDateInput = screen.getByLabelText(/maturity date/i);

    // WHEN - Set effective date
    await user.clear(effectiveDateInput);
    await user.type(effectiveDateInput, '2025-01-15');

    // WHEN - Set maturity date before or equal to effective date
    await user.clear(maturityDateInput);
    await user.type(maturityDateInput, '2025-01-10');
    await user.tab();

    // THEN - Error appears
    await waitFor(() => {
      expect(screen.getByText(/maturity date must be after effective date/i)).toBeInTheDocument();
    });

    // WHEN - Set maturity date after effective date
    await user.clear(maturityDateInput);
    await user.type(maturityDateInput, '2030-01-15');
    await user.tab();

    // THEN - No error
    await waitFor(() => {
      expect(screen.queryByText(/maturity date must be after effective date/i)).not.toBeInTheDocument();
    });
  });

  /**
   * AC6 - Validation Rule 5: Accrual Start Date <= Effective Date
   */
  it('should validate that accrual start date is not after effective date', async () => {
    // GIVEN
    allure.description('Test date validation: accrualStartDate <= effectiveDate');
    const user = userEvent.setup();
    render(<CDSTradeForm />);

    const effectiveDateInput = screen.getByLabelText(/effective date/i);
    const accrualStartInput = screen.getByLabelText(/accrual start date/i);

    // WHEN - Set effective date
    await user.clear(effectiveDateInput);
    await user.type(effectiveDateInput, '2025-01-15');

    // WHEN - Set accrual start after effective date
    await user.clear(accrualStartInput);
    await user.type(accrualStartInput, '2025-01-20');
    await user.tab();

    // THEN - Error appears
    await waitFor(() => {
      expect(screen.getByText(/accrual start date must be on or before effective date/i)).toBeInTheDocument();
    });

    // WHEN - Set accrual start equal to effective date
    await user.clear(accrualStartInput);
    await user.type(accrualStartInput, '2025-01-15');
    await user.tab();

    // THEN - No error
    await waitFor(() => {
      expect(screen.queryByText(/accrual start date must be on or before effective date/i)).not.toBeInTheDocument();
    });

    // WHEN - Set accrual start before effective date
    await user.clear(accrualStartInput);
    await user.type(accrualStartInput, '2025-01-10');
    await user.tab();

    // THEN - No error
    await waitFor(() => {
      expect(screen.queryByText(/accrual start date must be on or before effective date/i)).not.toBeInTheDocument();
    });
  });

  /**
   * AC7: Responsive layout - desktop vs mobile
   */
  it('should display responsive layout based on viewport size', () => {
    // GIVEN
    allure.description('Verify layout adapts to desktop and mobile viewports');

    // WHEN - Desktop viewport
    global.innerWidth = 1920;
    global.innerHeight = 1080;
    global.dispatchEvent(new Event('resize'));

    const { container: desktopContainer } = render(<CDSTradeForm />);

    // THEN - Multi-column layout on desktop
    const desktopForm = desktopContainer.querySelector('form');
    expect(desktopForm?.className).toMatch(/grid|columns-2|columns-3|grid-cols-2|grid-cols-3/i);

    // WHEN - Mobile viewport
    global.innerWidth = 375;
    global.innerHeight = 667;
    global.dispatchEvent(new Event('resize'));

    const { container: mobileContainer } = render(<CDSTradeForm />);

    // THEN - Single column layout on mobile
    const mobileForm = mobileContainer.querySelector('form');
    expect(mobileForm?.className).not.toMatch(/columns-2|columns-3|grid-cols-2|grid-cols-3/i);
    expect(mobileForm?.className).toMatch(/flex-col|block|columns-1|grid-cols-1/i);
  });

  /**
   * Integration Test: Complete submission flow
   */
  it('should successfully submit a complete valid trade form', async () => {
    // GIVEN
    allure.description('End-to-end test: Fill all fields and submit valid trade');
    const user = userEvent.setup();
    const mockSubmit = jest.fn();
    render(<CDSTradeForm onSubmit={mockSubmit} />);

    // WHEN - Fill all required fields with valid data
    await user.type(screen.getByLabelText(/notional amount/i), '10000000');
    await user.type(screen.getByLabelText(/spread/i), '150');
    await user.type(screen.getByLabelText(/effective date/i), '2025-01-15');
    await user.type(screen.getByLabelText(/maturity date/i), '2030-01-15');
    await user.type(screen.getByLabelText(/accrual start date/i), '2025-01-15');

    // Defaults should already be set for these:
    // - tradeDate = today
    // - currency = USD
    // - premiumFrequency = QUARTERLY
    // - dayCountConvention = ACT_360
    // - buySellProtection = BUY
    // - paymentCalendar = NYC

    // WHEN - Submit form
    const submitButton = screen.getByRole('button', { name: /submit|save|create/i });
    await user.click(submitButton);

    // THEN - Form submits successfully
    await waitFor(() => {
      expect(mockSubmit).toHaveBeenCalledTimes(1);
    });

    // THEN - Submitted data structure is correct
    const submittedData = mockSubmit.mock.calls[0][0];
    expect(submittedData).toMatchObject({
      notionalAmount: 10000000,
      spread: 150,
      currency: 'USD',
      premiumFrequency: 'QUARTERLY',
      dayCountConvention: 'ACT_360',
      buySellProtection: 'BUY',
      paymentCalendar: 'NYC',
      effectiveDate: '2025-01-15',
      maturityDate: '2030-01-15',
      accrualStartDate: '2025-01-15'
    });
  });
});
